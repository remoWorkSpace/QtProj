# C
## Union
联合体占用的内存等于最长的成员占用的内存。
union data{
    int n;
    char ch;
    short m;
    char a[2];
}
成员 n、ch、m、a[2] 在内存中“对齐”到一头
如下为绝大多数PC机上的内存分布情况，采用小端字节序，低对低。

地址
低     ——   ——  ——  ——  ——      ——   ——  ——  ——  ——      ——   ——  ——  ——  ——      ——   ——  ——  ——  ——      ——   ——  ——  ——  —— 
      |54| a[0] ch  .   .      |39| a[0] ch  .   .      |59| a[0] ch  .   .      |40| a[0] ch  .   .      |0A| a[0] ch  .   .
       ——   ——  ——  m   .       ——   ——  ——  m   .       ——   ——  ——  m   .       ——   ——  ——  m   .       ——   ——  ——  m   .
      |AD| a[1]     .   .      |00| a[1]     .   .      |20| a[1]     .   .      |00| a[1]     .   .      |01| a[1]     .   .
       ——   ——     ——   n       ——   ——     ——   n       ——   ——     ——   n       ——   ——     ——   n       ——   ——     ——   n
      |25|              .      |00|              .      |00|              .      |00|              .      |00|              .
       ——               .       ——               .       ——               .       ——               .       ——               .
      |3E|              .      |00|              .      |00|              .      |00|              .      |00|              .
高     ——               ——      ——               ——      ——               ——      ——               ——      ——               ——
     data.n = 0x3E25AD54;      data.ch = '9';           data.m = 0x2059;         data.n = 0x40;           data.a[0] = 0xa;data.a[1] = 0x1;
  
# C++
## 程序设计基本概念
1、数组的长度可以在运行时（run time）决定，只是不能定义时赋值。

2、基于范围的for循环（c++11支持）
for(char c : s)
对数组(或容器类,如vector和array)的每个元素执行相同的操作
string类也支持这种对字符的遍历循环操作

for(char &c : s)
可以实际地改变字符串s中的字符

3、C中 printf计算参数时是从右到左压栈的。
  printf(“%d,%d\n”,*ptr,*(++ptr));
  从右到左计算
  
4、浮点数内存存储方式
|            第一字节            |            第二字节            |            第三字节            |           第四字节            |
|1	|2	|3	|4	|5	|6	|7	|8	|1	|2	|3	|4	|5	|6	|7	|8	|1	|2	|3	|4	|5	|6	|7	|8	|1	|2	|3	|4	|5	|6	|7	|8	|
|符号|---------指数部分（8b）---------|------------------------------------基数部分（23b）-----------------------------------------|

(1) 134.375的内存存放：
   2|134  0                      0.375*2 = 0.75   0
   2|67   1                      0.75*2 = 1.5     1
   2|33   1                      0.5*2 = 1.0      1
   2|16   0
   2|8    0
   2|4    0
   2|2    0
     1    1
   134 = 0b10000110              0.375 = 0.011
   134.375 = 0b10000110.011 = 0b1.0000110011*2^7
   符号位：0
   指数位：127+7=134=0b10000110（这部分中是以2^7-1即127，也即01111111代表2^0，转换时需要根据127作偏移调整）
   基数位：0000110011（后续补齐0到23位）
   |1	|2	|3	|4	|5	|6	|7	|8	|1	|2	|3	|4	|5	|6	|7	|8	|1	|2	|3	|4	|5	|6	|7	|8	|1	|2	|3	|4	|5	|6	|7	|8	|
   |0   |1   0   0   0   0   1   1   0  |0   0   0   0   1   1   0   0   1   1   0   0   0   0   0   0   0   0   0   0   0   0   0  |

(2) 1.0f 的内存存放：
   1.0 = 0b1.0*2^0
   符号位：0
   指数位：127=0b01111111
   基数位：0b0...0(31个0)
   |1	|2	|3	|4	|5	|6	|7	|8	|1	|2	|3	|4	|5	|6	|7	|8	|1	|2	|3	|4	|5	|6	|7	|8	|1	|2	|3	|4	|5	|6	|7	|8	|
   |0   |0   1   1   1   1   1   1   1  |0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0  |
   1.0f = 0x3f800000;
(3) 0.0f 的内存存放：
   0.0f = 0x0000;

二进制前缀：0b
八进制前缀：0o
十六进制：0x

5、算式运算：变量类型自动提升、运算符优先级【整体结合()[]->.::向右++--等、向左取非取反取地址取内容类型强转向左++--等、先乘除后加减再移位】
   unsigned char a = 0xA5;//0b10100101
   unsigned char b = ~a>>4+1;
   printf("b=%d\n", b);
   (1)类型不同，则类型提升，a从unsigned char提升至int，(int)a=0x000000A5;
   (2)运算符优先级，~ > + > >> 
   (3)赋值时类型不同，类型降级，从int将为 unsigned char
   故 (int)~a=0xFFFFFF5A;
      4+1=5;
      0xFFFFFF5A >> 5 = 0xFFFFFFFA;
      截取为unsigned char 后 b = 0xFA;

6、a、b交换，不使用中间量
   a = a^b; OK          a=a+b; 这种方法不好，如果a、b都比较大，a+b容易越界
   b = a^b;             b=a-b;
   a = a^b;             a=a-b;
   
   
## 预处理 const sizeof
### 预处理 #define
1、一年有多少秒
 #define FIND SEC_PER_YEAR (365*24*60*60)UL
 注意：宏定义做替换，必须加括号（），没有分号；
      表达式有可能使整形溢出，考虑用长整型 UL

### const
const 相比 #define 宏定义，有类型，可以做类型安全检查。
const可以定义常量；定义函数返回值，函数体，函数参数。
定义类中某个成员函数为const函数，即不改变类中的数据成员。
在const成员函数中，用mutable修饰成员变量名后，可以修改类的成员变量。

### sizeof
判断数据类型长度符的关键字
注意点：
1、char a[] = "nihao"; sizeof(a) = 6;//加\0终止符
2、char a[20] = "nihao"; sizof(a) = 20;//char a[20] 类型的大小
3、int a[10]; sizeof(a) = 4*10 = 40;
4、int func(char a[]){ sizeof(a) = 4;}//数组在函数入参时退化为指针，不论什么指针，32位环境sizeof都是4，64位环境都是8。
5、struct a{
	char b;
	int c;
}; sizeof(a) = 8;//结构体的sizeof 需要注意最大类型的整数倍，字节对齐！
6、字节对齐的细节和编译器实现相关，但一般而言，满足三个准则：
1)结构体变量的首地址能够被其最宽基本类型成员的大小所整除；
2)结构体每个成员相对于结构体首地址的偏移量（offset）都是成员大小的整数倍，如有需要编译器会在成员之间加上填充字节（internal padding）；
3)结构体的总大小为结构体最宽基本类型成员大小的整数倍，如有需要编译器会在最末一个成员之后加上填充字节（trailing padding）。


## 指针与引用
### 数组、指针、指针数组、数组的指针、函数入参数组退化为指针、函数指针
1、数组：int a[10];
//数组是一个容器，容器本身是一个常量，只是用数组首地址表示，即0号元素的地址。所以数组名++这种运算是错误的。
//数组元素是变量，里面的值可以变。

2、指针：int *a;
//单纯的指针是一个变量，不需要释放，用new/new[]/malloc出来的内存空间才需要delete/delete[]/free释放。

3、指针数组：int *p[10];
//数组，存放10个 int* 指针类型的变量

4、数组的指针：int (*p)[10];
//指向数组的指针，数组里存放10个int 类型变量
//*p++，由于++和*同优先级，结合方向自右而左，等价于*(p++)
//*(p++)与*(++p)作用不同。若p的初值为a，则*(p++)等价a[0]，*(++p)等价a[1]。

5、函数入参的数组退化为指针：
void func(int b[], int c); int a[10]; func(a){}
void func(int *b, int c);  int a[10]; func(a){}

- 二维数组：int a[3][4]
a|a[0]|a[1]|a[2]|
   |    |    |
   |    |    |
a'[0] a'[0] a'[0]
a'[1] a'[1] a'[1]
a'[2] a'[2] a'[2]
a'[3] a'[3] a'[3]
在一维数组中，数组名表示的是数组第一个元素的地址，二维数组就是一维数组，
例如：二维数组 a[3][4]，就是有三个元素 a[0]、a[1]、a[2]的一维数组，所以数组 a 的第一个元素不是 a[0][0]，而是 a[0]，
所以数组名 a 表示的不是元素a[0][0]的地址，而是 a[0]的地址，即：a == &a[0];
而 a[0] 又是 a[0][0]的地址，即：a[0] = &a[0][0];
所以二维数组名 a 和元素 a[0][0]的关系是：a = &(&a[0][0]);
即二维数组名 a 是地址的地址，必须两次取值才可以取出数组中存储的数据。

- a[M][N]数组中存放了 M 个 a'[N] 数组的地址
对于二维数组a[M][N]，数组名 a 的类型为int(*)[N]，所以如果定义了一个指针变量 p：int *p;并希望这个指针变量指向二维数组 a，那么不能把 a 赋给 p，因为它们的类型不一样。要么把&a[0][0]赋给 p，要么把 a[0] 赋给 p，要么把*a 赋给 p。因为 a==&(&a[0][0])，所以 *a==*(&(&a[0][0]))==&a[0][0]。

- 定义指针变量 int(*)[N] 型与二维数组的关系
当指针变量 p 定义成 int(*)[N] 型，这时就可以把 a 赋给 p。p == a;
那么此时p以“行”为单位 指向元素a[i][j]。数组名 a 代表第一个元素 a[0]的地址，则a+1就代表元素 a[1]的地址，即a+1==&a[1]；a+2就代表 a[2]的地址，即 a+2==&a[2]……a+i就代表 a[i]的地址，即
a+i = &a[i];
p+i = &a[i];
*(p+i) == a[i];//等式两边作“*”运算
*(p+i) +j == &a[i][j];//等式两边同时加上j行
（1）当二级指针（例如：类型为int **）作为函数形参时，能作为函数实参的是二级指针，指针数组（例如：类型为int *[]），一级指针的地址 （例如：类型为int **）
（2）当数组指针作为函数形参时，能作为函数实参的是二维数组（例如：类型为int(*)[N]），数组指针（例如：类型为int(*)[N]）
（3）当二维数组作为函数形参时，能作为函数实参的是二维数组，数组指针
（4）当指针数组作为函数形参时，能作为函数实参的是指针数组，二级指针,一级指针的地址
<!--    void fun1(int **pp)
        {
            printf(“fun1\n”);
        }
        void fun2(int(*c)[5])
        {
            printf(“fun2\n”);
        }
        void fun3(int a[][5])
        {
            printf(“fun3\n”);
        }
        void fun4(int *pa[5])
        {
            printf(“fun4\n”);
        }
        int main()
        {
            int *pa[5]; //指针数组
            int **pp = NULL; //二级指针
            int *p = NULL; //一级指针
            int a[5][5]; //二维数组
            int b[5]; //一维数组
            int(*c)[5] = &b; //数组指针
            // 当二级指针作为函数形参时，能作为函数实参的是二级指针，指针数组，一级指针的地址
            fun1(pa);
            fun1(pp);
            fun1(&p);
            printf("\n");
            // 当数组指针作为函数形参时，能作为函数实参的是二维数组，数组指针
            fun2(a);
            fun2©;
            printf("\n");
            // 当二维数组作为函数形参时，能作为函数实参的是二维数组，数组指针
            fun3(a);
            fun3©;
            printf("\n");
            // 当指针数组作为函数形参时，能作为函数实参的是指针数组，二级指针,一级指针的地址
            fun4(pa);
            fun4(pp);
            fun4(&p);
            printf("\n");
            return 0;
        } -->

若 int input[3][2]={{1,2},{4,5},{7,8}}; 且 sum 函数调用为 int total = sum(input, 3); 则 sum 函数的原型为（D）
（A）int sum(int *a[], int len)
（B）int sum(int (*a)[], int len)
（C）int sum(int *a[2], int len)
（D）int sum(int (*a)[2], int len)
//解析：D 中 [] 里需要有 2，不表示具体含义，只是提示作用，但是如果不写2，编译器会报错。

6、函数的指针:
//


## 循环、递归与概率
## STL模版与容器
## 面向对象
## 继承与接口
## 位运算与嵌入式编程




## typedef struct 别名
typedef struct stackNode{
    int data;
    stackNode *p;
}node,*Node;

node a;
Node pA;

## C语言中左值右值
在赋值运算符 = 左边的是左值，代表的是一块内存单元；
在右边的是右值，代表的是内存单元上的值。


## 不同类型与零值比较的if语句
bool flag;//bool值，零值为false，非零值都为true，因为true不是唯一值，所以不能与true直接比较
    if(a)//真 
    if(!a)//假
double b;//float和double值都有精度限制，不能直接与0值作比较
    if((b>=-MIN) && (b<=MIN))
    MIN 可以是0.00000001。
int a;//int值，与零值比较，不能用if(a)，如果误解为bool变量
    if(0 == a)
    if(0 != a)
void* p;
    if(NULL == p)

## malloc/free && new/delete
- malloc/free 为C 的标准库函数，函数原型：
void* malloc(size_t size);//参数代表字节个数
void  free(void* pointer);//参数代表内存地址
- malloc/free 只开辟内存空间并释放；
- malloc 开辟内存要检查判空，可能开辟失败返回NULL；
- malloc 申请内存，大小需手动计算；
- malloc 和 new 都支持多线程。

- new/delete 为C++ 的操作运算符，调用的分别为赋值运算符重载 operator new() 和 operator delete()；
- new/delete 开辟内存空间并释放，且调用构造函数和析构函数进行初始化和清理；
- new 内存分配失败抛出BAD_ALLOC 异常；
- new 申请内存时，大小由编译器自己计算；


## C++ string 和 C 字符串
C中没有字符串这个数据类型，C 字符串 实际上就是一个以null('\0')字符结尾的字符数组。
定义时可以用"="号初始化，但是以后不能利用"="对C字符串进行赋值。

|						|C 字符串				|C++ string				|
|声明					|char str[20];			|string str;			|
|初始化					|char str[20] = "nihao";|string str = "nihao";	|
|字符串赋值				|strcpy(str,"wohenhao");|str = "wohenhao";		|
|使用null字符('\0')么？	|使用					|不使用					|

C++ string 其他构造方式:
string str = string(5, 'c');
string str1("nihao", 3);
string str2(str1, 1, 2);

## string/char*/const char*/int 类型转换
[参考](file:///F:/1_编译型语言_C++/总结-int&string.txt)
string => const char*
    string str = "nihao";
    const char* pCh = str.c_str();
    const char* pCh = str.data();
string => char*
    string str = "nihao";
    int iLen = str.length();
    char *pCh = (char*)malloc((iLen+1)*sizeof(char));
    alert(pCh!=NULL);
    str.copy(pCh, iLen, 0);
char* => string
    char *pCh = "wohenhao";
    string str = pCh;
    string str(pCh, strlen(pCh));
char* => char[]
    char *pCh = "nihao";
    char str[] = "wohenhao";
    strcpy(str, pCh, strlen(pCh)+1);
const char* => char*
    const char *st = "lala";
    char *ncstr = new char[strlen(st) + 1];
    strcpy(ncstr, st);
ps: printf("%s", str);是错误的,因为 %s 要求后面的对象的首地址, 而 str是对象, 不是首地址.

string => int
    string str = "123";
    int iNum = atoi(str.c_str());
int => string
    int iNum = 123;
    string str = to_string(iNum);
    
    char strc[100];
    string str = itoa(iNum, strc, 10);



## 进程间同步？
进程指正在运行的程序
## 线程间通信和同步
线程是进程中的一个执行单元

## 锁


叠拓面试时问了一个什么线程安全的？


## 重载，重写


## socket编程？
## xml
## TCP-IP协议/HTTP
## 抓包wireshark

## 匿名内部类
如果在一个类里面定义一个类，那么这个类就是内部类，外面的那个类就是外部类，这个很好理解。内部类就相当于外部类的一个成员，你可以把内部类看成一个整体。
内部类分为：静态内部类，非静态内部类。匿名内部类是非静态内部类的一种特殊情况，匿名内部类没有类名，因此就不可能有构造函数，不能创建对象。除此之外还有局部内部类，就是定义在方法内的，这个一般不怎么用，不需要掌握，知道就好，本文主要说匿名内部类，其他内部类以后会说。


## 三维坐标的模板代码 来自《深度探索C++对象模型》
#define X(p,ival) (p.x) = (ival)

Class Point3d
{
public:
    Point3d(float x=0.0, float y=0.0, float z=0.0):_x(x),_y(y),_z(z){}
    
    float x(){ return _x;}
    float y(){ return _y;}
    float z(){ return _z;}
    
    void X(float x){ _x = x;}
private:
    float _x;
    float _y;
    float _z;
};

inline ostream& 
operator<<(ostream &os, const Point3d &pt)
{
    return os<<"(" << pt.x() << ", " << pt.y() << ", " << pt.z() << ")";
}

template < class type >
class Point3d
{
public:
    Point3d(type x, type y, type z):_x(x),_y(y),_z(z) {}
    type x(){return _x;}
    type y(){return _y;}
    type z(){return _z;}
    
    void X(type tval){_x = tval;}
private:
    type _x;
    type _y;
    type _z;
};

template < class type, int dim >
class Point
{
public:
    Point(type coords[dim]){
        for(int i=0; i<dim; i++ )
        {
            _coords[i] = coords[i];
        }
    }
    
    type operator[](int i)
    {
        assert(i>=0 && i<dim);
        return _coords(i);
    }
private:
    _coords[index];
};

vector可以下标迭代
构造函数
下标找
find和结果比较

# STL（Standard Template Library） for C++
## 容器：
STL容器就是将运用最广泛的一些数据结构实现出来。分序列式容器+关联式容器。
参考：[](file:///F:/3_STL/基础篇：STL容器和算法 - 知乎.html)
     [](file:///F:/3_STL/史上最全的各种C++ STL容器全解析 - Seaway-Fu - 博客园.html)
vector，list区别
- vector 向量：可扩展的数组
         优点：支持随机访问，支持[]操作和 .at()，查询效率高
         缺点：和数组相同，当向其头部或中部插入或删除元素时，为了保持原本的相对次序，插入或删除点之后的所有元素都必须移动，所以插入的效率比较低。
         使用场景：适用于对象简单，变化较小，并且频繁随机访问的场景。
- array 数组：固定大小的数组，比传统数组封装了一些操作函数
- deque 双端队列：由一段一段定量连续空间构成。
        一旦要在 deque 的前端和尾端增加新空间，便配置一段定量连续空间（1 或 3），串在整个 deque （1）的头端或尾端；
        在中间部分（1）安插元素则比较费时，因为必须移动其它元素。
        在分段的连续空间上，维护整体连续的假象。
                              2                   deque 1                     3
        ... ... |	|	|	| ... ... |    |    |    | ... ... |    |    |    | ... ... 
        deque 是 list和 vector的折中方案。
        优点：支持随机访问，支持[]操作和 .at()，查询效率高，可双端进行pop、push。
        缺点：不适合中间插入删除操作；占用内存多；
        适用场景：适用于既要频繁随机存取，又要关心两端数据的插入与删除的场景。
- list 列表：由双向链表实现。
        优点：内存不连续，动态操作，可在任意位置插入或删除且效率高。
        缺点：不支持随机访问。
        适用场景：适用于经常进行插入和删除操作并且不经常随机访问的场景。
- forward_list 列表容器：由单向链表实现，使用方法和list基本类似。
        不支持随机访问。
        标准库容器中唯一不提供 size() 方法的容器。
- set 集合：由红黑树实现。
        内部元素依据其值自动排序，每个元素值只能出现一次，不允许重复。
        set 中的元素都是排好序的，集合中没有重复的元素。
        优点：使用平衡二叉树实现，便于元素查找，且保持了元素的唯一性，以及能自动排序。
        缺点：每次插入值的时候，都需要调整红黑树，效率有一定影响。
        适用场景：适用于经常查找一个元素是否在某群集中且需要排序的场景。
- multiset 多重集合：和 set 相同，只不过它允许重复元素，也就是说 multiset 可包括多个数值相同的元素。
- map 映射：由红黑树实现。
        其元素都是 “键值/实值” 所形成的一个对组（key/value pairs)。每个元素有一个键，是排序准则的基础。每一个键只能出现一次，不允许重复。
        map 内部自建一颗红黑树，这颗树具有对数据自动排序的功能，所以在 map 内部所有的数据都是有序的。
        该容器存储的是键值对，所以插入函数要使用pair<> 构造键值对对象。
        优点：使用平衡二叉树实现，便于元素查找，且能把一个值映射成另一个值，可以创建字典。
        缺点：每次插入值的时候，都需要调整红黑树，效率有一定影响。
        适用场景：适用于需要存储一个数据字典，并要求方便地根据key找value的场景。
- multimap 多重映射：和 map 相同，但允许重复元素，也就是说 multimap 可包含多个键值（key）相同的元素。
        
        map 和 set 的插入删除效率比用其他序列容器高，因为对于关联容器来说，不需要做内存拷贝和内存移动。

- tuple 元组：解决| 1.容器只能存放一个类型数据   | 的问题，而出现的容器，可以保存3种类型？
                 | 2.std::pair只能保存两个元素 |

容器配接器：
- stack 栈
- queue 队列
- priority_queue

- pair 类模板：pair<int, float> p1; //调用构造函数来创建pair对象
              make_pair(1,1.2);    //调用 make_pair()函数来创建 pair对象, 实际 make_pair() 函数内调用的仍然是 pair 构造函数.
             
——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
C++11 STL新增了 std::array
array/vector/数组：
都可以使用下标[]
都是连续内存

构造  array<int, 5> arrayData;                                                      vector<int> vecData(5, 30);//5个元素均为30
      array<int, 5> arrayData = {1,2,3,4,5};                                        vector<int> vecData = {1,2,3,4,5};
                                                                                    vector<int> vecData;
                                                                                   
初始化 arrayData.fill(5);//用5填充所有元素                                            vecData[i] = 5;//如果声明空向量，不能直接如此初始化，会内存非法操作
      arrayData = {1,2,3,4,5}                                                                             
访问   arrayData.at(i);                                                             vecData.at(i);
                                                                                
增加   arrayData[i] = 5;//静态增加(改变)数据                                          vecData.push_back(5);//尾部动态增加元素5，如果声明空向量，必须先动态赋值
       arrayData.at(i) =5;//静态增加(改变)数据                                       vecData.emplace_back(6);//尾部动态增加元素6
                                                                                   vector<int>::iterator it = vecData.end();
                                                                                   vecData.insert(it, {7,8});//尾部动态增加7，8，迭代器 it可以改变位置
                                                                                
删除   //静态删除（改变）数据                                                         vecData.pop_back();//尾部动态删除一个元素

查找 for(array<int,5>::iterator it=arrayData.begin();it!=arrayData.end();it++)     for(vector<int>::iterator it = vecData.begin(); it != vecData.end(); it++)
     //有迭代器，但是没有find函数                                                    //有迭代器，没有find函数
——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

构造  stack<int> stackData;                                                          queue<int> queueData;
                                                                                        
初始化 NA                                                                            NA
                                                                                        
访问  stackData.top();//返回栈顶元素                                                  queueData.front();//返回队首元素
                                                                                    queueData.back();//返回队尾元素
                                                                                        
增加 stack.push(5);//在栈顶增加一个元素                                                queueData.push();//在末尾增加一个元素
                                                                                        
删除 stack.pop();//在栈顶删除一个元素                                                  queueData.pop();//在队首删除一个元素
                                                                                        
查找 while(!stack.empty())//遍历查找，无find方法                                       while(!queueData.empty())//遍历查找，无find方法
——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

构造      string str(5, 'c');                                                     map<int,int> mapData;
         string str("jintianhenhao");                                             unordered_map<int,string> mapData={{5,"zhang"},{6,"wang"}}; 

初始化   str = "henhao";                                                           
        str1 = str2; str3 = str1+str2;
        
访问     str1[5];                                                                 unordered_map<int,string>::iterator it=mapData.find(5);
        str1.at(5);                                                               *it->second;

增加    str1.append(10,'!');//字符串末尾追加10个！                                  mapData[2] = "xu";//使用[]进行单个插入，若存在键值2，则赋值修改，若无则插入
                                                                                 mapData.insert(pair<int,string>(3,"liu"));
                                                                                 
删除    str1.erase(5);//删除位置5以后的所有字符 string::npos(unsigned int)          mapData.erase(it);
        str1.erase(5,3);//删除位置5以后的3个字符
        string::iterator it=str1.begin();
        str1.erase(it);//删除it指向的字符 string::iterator

查找    unsigned int iPos=str1.find("nihao", 0);//从0位置开始找"nihao"             unordered_map<int,string>::iterator it=mapData.find(5);
       if(string::npos != iPos)                                                  if(mapData.end() != it)


## 算法：
冒泡算法、选择排序、插入排序、希尔排序、归并排序、快速排序、堆排序
计数排序、桶排序、基数排序
参考本地文件：[](file:///F:/3_STL/十大经典排序算法（动图演示） - 一像素 - 博客园.html)
            [](file:///F:/3_STL/十大经典排序算法（动图演示） - 一像素 - 博客园_files)

事件复杂度/空间复杂度/稳定性

### 算法练习题:
### 1、冒泡算法
/* 0. 冒泡算法
#include <iostream>
using namespace std;

int main()
{
    //冒泡算法：数组，最后从大到小排列
    int a[10] = {3,5,2,0,4,1,9,3,1,8};
    for (int i = 0; i < 10; i++)
    {
        printf("a = %d\n", a[i]);
    }

    printf("\n\n");

    for (int j = 0; j <= 9; j++)
    {
        //第一遍，从尾到头，大的往前排
        for (int i = 9; i > j; i--)
        {
            int b = 0;
            if (a[i] > a[i - 1])
            {
                b = a[i - 1];
                a[i - 1] = a[i];
                a[i] = b;
            }
        }
    }

    for (int i = 0; i < 10; i++)
    {
        printf("b = %d\n", a[i]);
    }

    printf("\n\n");
    
    printf("Hello, world.\n");
    return 0;
}
*/

## 
### 2、String函数  如下参考[C++数据结构和算法](https://blog.csdn.net/u014796694/article/details/81436373)
/* 1. string函数 
#include <iostream>
using namespace std;

class String
{
private:
    char* content = nullptr;
    int length;
public:
    String(const char* strTemp = nullptr);//默认构造函数
    String(const String& strTemp);        //拷贝构造函数
    ~String();                            //析构函数

    String& operator=(const String& strTemp);//赋值构造函数

    const char* c_str()const;//获取字符串
    int getLength()const;//获取长度
};

int String::getLength() const
{
    return length;
}

const char* String::c_str() const
{
    return content;
}

String::String(const char* strTemp)
{
    if (nullptr == strTemp)//char*类型，优先用nullptr
    {
        content = new char[1];
        *content = '\0';
        length = 0;
    }
    else
    {
        length = strlen(strTemp);
        content = new char[length + 1];
        strcpy_s(content, length+1, strTemp);
    }

    cout << "String::String(const char* strTemp) :" << this->content<<endl;
    return;
}

String::String(const String& strTemp)
{
    //  String类型中的content不存在nullptr的情况 
    //if (nullptr == strTemp.c_str())
    //{
    //    content = new char[1];
    //    *content = '\0';
    //    length = 0;
    //}
    //else
    //{

    cout << "String::String(const String& strTemp) :" << this->content << endl;
    length = strTemp.getLength();
    content = new char[length + 1];
    strcpy_s(content, length+1, strTemp.c_str());
    return;
}


String::~String()
{
    cout << "String::~String() :" << this->content << endl;
    delete[] content;
    content = nullptr;
    length = 0;
    return;
}

String& String::operator = (const String & strTemp)
{
    //注意判断是否自己赋值给自己
    if (this == &strTemp)
    {
        return *this;
    }
    
    //注意不是构造函数，所以之前已经有的内存先释放掉
    delete[] content;

    length = strTemp.getLength();
    content = new char[length + 1];
    strcpy_s(content, length+1, strTemp.c_str());
    return *this;
}

int main()
{
    printf("nihao.\n");
    //单个String指针
    String *strVar = new String("wohenhaoaaaaa.\n");
    delete strVar;

    //String指针数组
    String* strVar1 = new String[3]{ "test" ,"henhao","China"};
    delete[] strVar1;
    return 0;
}
*/

### 3、顺序链表
/* 2. 顺序链表【数组实现】
#include <iostream>
using namespace std;

#define MAXLEN 30
typedef int DATATYPE;

struct SqList
{
    DATATYPE content[MAXLEN];
    int iLength;
};

void initSqList(SqList* &L)
{
    L = (SqList*)malloc(sizeof(SqList));
    L->iLength = 0;
}

void destroySqList(SqList* &L)
{
    if (NULL == L)
    {
        return;
    }
    free(L);
    L = NULL;
    return;
}

bool isEmptySqList(SqList* L)
{
    if ((NULL == L)||(0 == L->iLength))
    {
        cout << "isEmptySqList pointer NULL error." << endl;
        return true;
    }
    
    return false;
}

DATATYPE getSqLiteData(SqList* L, int i)
{
    if (NULL == L || NULL == L->content)
    {
        cout << "getSqListData pointer NULL error" << endl;
        return 0;
    }

    if (i>=L->iLength)
    {
        cout << "getSqList range error" << endl;
        return 0;
    }
    return L->content[i-1];
}

int getDataPosition(SqList* L, DATATYPE iData)
{
    if (NULL == L)
    {
        cout << "getDataPosition pointer NULL error." << endl;
        return -1;
    }
    
    for (int i = 0; i < L->iLength; i++)
    {
        if (iData == L->content[i])
        {
            return i + 1;
        }
    }

    cout << "getDataPosition data error." << endl;
    return -1;
}

int main()
{
    cout << "wohaoa" << endl;
    SqList* sL = NULL;
    initSqList(sL);
    for (int i = 0; i < MAXLEN; i++)
    {
        sL->content[i] = i;
    }
    sL->iLength = MAXLEN;

    bool bK = isEmptySqList(sL);
    if (bK)
    {
        string strBuffer = (true == bK) ? "empty" : "not empty";
        cout << "sK is " << strBuffer << endl;
    }

    DATATYPE iContent = getSqLiteData(sL, 5);
    cout << "sK 5 data is " << iContent << endl;

    int iPos = getDataPosition(sL, 9);
    cout << "sK " << iPos << " data is 9." << endl;

    return 0;

}

*/

### 4、单链表
/* 单链表
#include <iostream>
using namespace std;

typedef int DATATYPE;

typedef struct listNode
{
    DATATYPE content;
    listNode* pNext;
}LinkList;


void initLinkList(LinkList*& L)
{
    L = (LinkList*)malloc(sizeof(listNode));
    L->pNext = NULL;
}


void destroyLinkList(LinkList*& L)
{
    if (NULL == L)
    {
        return;
    }

    listNode* pNode;
    {
        pNode = L;
        L = L->pNext;
        free(pNode);

    }while (NULL != L);
    
    return;
}

void insertLinkList(LinkList*& L, int i, DATATYPE iData)
{
    listNode* pNode = (listNode*)malloc(sizeof(listNode));
    pNode->content = iData;
    pNode->pNext = NULL;

    if (NULL == L)
    {
        L = pNode;
        return;
    }
    
    listNode* pTemp = L;
    int j = 0;

    while (j<i-2 && NULL != pTemp->pNext)
    {
        pTemp = pTemp->pNext;
        j++;
    }

    if (NULL == pTemp->pNext)
    {
        pTemp->pNext = pNode;
    }

    pNode->pNext = pTemp->pNext;
    pTemp->pNext = pNode;    
    
    return;

}

DATATYPE deleteLinkList(LinkList*& L, int i)
{
    if (NULL == L)
    {
        cout << "deleteLinkList pointer NULL error." << endl;
        return -1;
    }

    int j = 0;
    listNode* pNode = L;

    while (j<i-2 && NULL != pNode)
    {
        pNode = pNode->pNext;
        j++;
    }

    listNode* pDel = pNode->pNext;
    pNode->pNext = pDel->pNext;

    DATATYPE iData = pDel->content;
    free(pDel);

    return iData;
}

*/

### 5、双链表
/* 双链表 */
/* 关注点：dNode *a,*b; 第二个指针变量要带*号 */
/* 数组用下标直接找位置，或者用for循环找到目标位置 */
/* 链表用while循环找到目标位置 */
/*
#include <iostream>
using namespace std;

typedef int DATATYPE;

typedef struct dNode
{
    DATATYPE iContent;
    dNode* pPre;
    dNode* pNext;
}DLinkList;

void initDLinkList(DLinkList*& L)
{
    L = (DLinkList*)malloc(sizeof(DLinkList));
    L->pPre = NULL;
    L->pNext = NULL;
}

void destroyDLinkList(DLinkList*& L)
{
    if (NULL == L)
    {
        return;
    }

    dNode *pCurNode, *pNextNode;

    pCurNode = L;
    pNextNode = pCurNode->pNext;

    while (NULL != pNextNode)
    {
        free(pCurNode);
        pCurNode = pNextNode;
        pNextNode = pCurNode->pNext;
    }

    free(pCurNode);
    L = NULL;
    return;
}

void insertDLinkList(DLinkList*& L, int i, DATATYPE iData)
{
    if (NULL == L)
    {
        cout << "insertDLinkList pointer NULL error." << endl;
        return;
    }

    int j = 0;
    DLinkList* pCurNode, *pNextNode;
    pCurNode = L;
    pNextNode = pCurNode->pNext;

    while (j<i-3 && NULL != pCurNode)
    {
        pCurNode = pNextNode;
        pNextNode = pCurNode->pNext;
        j++;
    }

    if (j!=(i-2) && NULL == pCurNode)
    {
        cout << "insertDLinkList pointer NULL error." << endl;
        return;
    }

    DLinkList* pInsertNode = (DLinkList*)malloc(sizeof(DLinkList));
    pInsertNode->iContent = iData;

    pCurNode->pNext = pInsertNode;
    pInsertNode->pPre = pCurNode;
    pInsertNode->pNext = pNextNode;
    pNextNode->pPre = pInsertNode;
    
    return;
}

DATATYPE deleteDLinkList(DLinkList*& L, int i)
{
    if (NULL == L)
    {
        cout << "deleteDLinkList pointer NULL error." << endl;
        return -1;
    }

    DLinkList* pCurNode, *pNextNode;
    pCurNode = L;
    pNextNode = pCurNode->pNext;

    int j = 0;

    while (j<i-3 && NULL != pCurNode)
    {
        pCurNode = pNextNode;
        pNextNode = pCurNode->pNext;
        j++;
    }

    if (j!=(i-2) && NULL == pCurNode)
    {
        cout << "deleteDLinkList pointer NULL error." << endl;
        return -1;
    }

    DLinkList* pDelNode = pNextNode;
    pNextNode = pDelNode->pNext;

    pCurNode->pNext = pNextNode;
    pNextNode->pPre = pCurNode;

    DATATYPE iContent = pDelNode->iContent;
    free(pDelNode);
    return iContent;
}

int main()
{
    cout << "hello.\n" << endl;
    return 0;
}

*/
### 6、顺序队列
/* 队列 */
/* 顺序队列 */

    typedef struct SQueue //创建一个结构体，里面包含数组和队头和队尾
    {
        DataType data[MaxSize]; 
        int front, rear; //front表示队头，rear表示队尾，入队头不动尾动，出队尾不动头动
    }SqQueue;

### 7、链式队列

    //定义数据节点结构体
    typedef struct qnode
    {
        DataType Elem;
        struct qnode *next;
    }QDataNode;

    //定义链队节点结构体
    typedef struct 
    {
        QDataNode *front;
        QDataNode *rear;
    }LinkQueue;


### 8、顺序栈

    typedef struct Stack
    {
        DataType Elem[MaxSize];
        int top;        //栈指针
    }SqStack;

### 9、链式栈


    typedef struct LinkNode  //链式栈的结点定义和链表的结点定义是一样的
    {
        DataType Elem;                           //数据域
        struct LinkNode *next;                   //指针域
    }LinkStack;




### 10、链表反转  如下参考[C++算法](https://www.cnblogs.com/kuangbendesaozhu/p/13469488.html)
typedefine 





### 11、如下参考[C++经典算法题](https://blog.csdn.net/f_r_e_e_x/article/details/50770907)
。。。



## 迭代器：
举例： set<int> a;
     set<int>::iterator it = a.begin();
     for(; it!=a.end(); it++)
         cout<< *it <<endl;
     


# 数据结构
## 数据结构基础
         |逻辑结构——|线性结构（线性表、栈、队、串、数组）
         |         |非线性结构（树结构、图结构）
         |                 |顺序结构
数据结构——|物理（存储）结构——|链式结构
         |                |索引结构
         |                |散列结构
         |         |插入运算
         |         |删除运算
         |数据运算——|修改运算
         |         |查找运算
         |         |排序运算

顺序存储：把逻辑上相邻的数据元素存储在物理上相邻的存储单元中的存储结构。
链式存储：把逻辑上相邻的数据元素在物理上不一定相邻，通过指针来实现。

## 数组(array)：
    顺序存储，随机存取快
    特点：优点：存储密度大，存储空间利用率高；缺点：插入或删除元素时不方便。
    适宜于做查找这样的静态操作。
## 链表(list)：
    链式存取
    头节点是在链表的首元节点之前附设的一个节点，改节点的数据域可以为空，也可存放表长度等附加信息，作用为对链表操作时，可以对空表、非空表的情况以及对首元节点进行统一处理，编程更方便。
    无头节点时，头指针的值为空时表示空表；
    有头节点时，头节点的指针域为空时表示空表。
    特点：优点：插入或删除元素时很方便，使用灵活；缺点：存储密度小，存储空间利用率低。
    适宜于做插入、删除这样的动态操作。

## 栈(stack)：
    只准在一端进行插入和删除操作的线性表。
    入栈口诀：堆栈指针top“先压后加”：S[top++] = an+1
    出栈口诀：堆栈指针top“先减后弹”：e = S[--top]
    栈可以有顺序和链式存储结构。
    堆栈用途：调用函数或子程序；
            递归运算的有力工具；
            用于保护现场和恢复现场；
            简化了程序设计的问题。
## 队列(queue)
    只能在表的一端进行插入运算，在表的另一端进行删除运算的线性表。
    队列可以有顺序和链式存储结构。
    顺序队列有假溢出的问题：当尾指针已经到了数组上界，不能再有入队操作，但其实数组中还有空位置。解决途径——采用循环队列。
    空链队列的特征：front == rear
    队列的用途：离散事件模拟、OS作业调度和简化设计。
## 串（字符串）
    数据元素为字符的线性表。
    模式匹配即字串定位运算，即如何实现Index(S,T,pos)函数。

## 树(tree)
1. 二叉树（binary tree）
2. 二叉树分为：
    (1)完美二叉树（满二叉树）（深度为k，且有（2^(k+1)-1）个节点的二叉树称为满二叉树。满二叉树是完全二叉树的一个特例。）
    (2)完全二叉树（一棵深度为k的有n个结点的二叉树，对树中的结点按从上至下、从左到右的顺序进行编号，
                 如果编号为i（1≤i≤n）的结点与满二叉树中编号为i的结点在二叉树中的位置相同，则这棵二叉树称为完全二叉树。
                 即和满二叉树相比，前k-1 层是满的，但最底层却允许在右边缺少连续若干个节点。）
    (3)完满二叉树（除叶子节点外，每个节点都有2个孩子。）
    (4)子树：除根节点之外的其余数据元素被分为m(m>=0)个互不相交的集合T1,T2,...,Tm-1，其中每一个集合Ti(1<=i<=m)本身也是一棵树，被称作原树的子树（subtree）。
3. 二叉树的遍历主要有三种：
    （1）先(根)序遍历（根左右）
    （2）中(根)序遍历（左根右）
    （3）后(根)序遍历（左右根）
    （4）层次遍历（同广度优先遍历）
4. 二叉树的应用：
    哈夫曼树和哈夫曼编码
    Huffman树（最优二叉树）：带权路径长度最短的树，最小冗余编码、信息高效传输。
    Huffman编码：不等长编码
    二叉查找树：任意节点左子树不为空,则左子树的值均小于根节点的值
              任意节点右子树不为空,则右子树的值均大于于根节点的值
              任意节点的左右子树也分别是二叉查找树
    平衡二叉树：是一棵空树，或它的左右两个字树的高度差绝对不超过1，并且左右两棵字树都是一棵平衡二叉树。
    AVL树：带有平衡条件的二叉查找树
    红黑树：自平衡二叉查找树，典型用途是实现关联数组，主要用来存储有序的数据，时间复杂度是O(lgn)，效率非常高。

## 图（map）
    图的遍历：
    （1）深度优先搜索，仿二叉树的先序遍历
    （2）广度优先搜索
    求最短路径：在带权有向图中A点（源点）到达B点（终点）的多条路径中，寻找一条各边权值之和最小的路径。
    关键概念：连通图、生成树、邻接点。
    图有顺序和链式两种存储结构。
    prim 和 kruscal 算法，手工分步模拟生成树的生成过程。
    map的初始化、插入、查找、删除：
    map<int, int> mapData;
    mapData.insert(pair<int, int>(1,1));
    map<int, int>::iterator itr = mapData.find(1);
    if(mapData.end() != itr)
    {
        int data = itr->second;
    }
    mapData.erase(1);
    mapData.erase(itr);
    
    map内部实现了一个红黑树，红黑树具有自动排序的功能。
    unordered_map内部实现了一个哈希表（也叫散列表）。

## 集合（set）
    平衡二叉树

## 堆（heap）
    堆总是一棵完全二叉树。
    
## 哈希表
    给定表M，存在函数f(key)，对任意给定的关键字值key，代入函数后若能得到包含该关键字的记录在表中的地址，则称表M为哈希(Hash）表，函数f(key)为哈希(Hash) 函数。
    


# 设计模式
## 单例模式
有缺陷的懒汉式-------------->懒汉式单例------------------------>懒汉式单例(magic static)局部静态变量
			线程安全问题    加锁（双检锁）	在某些平台双检锁会失效	并发线程在获取静态局部变量的时候
			内存泄漏        使用共享指针	要求用户也使用共享指针	一定是初始化过的，所以具有线程安全性
																静态变量的生存期 是从声明到程序结束
参考文章：[](https://www.cnblogs.com/sunchaothu/p/10389842.html)

单例模式和多例模式说明：
1、单例模式和多例模式属于对象模式。
2、单例模式的对象在整个系统中只有一份，多例模式可以有多个实例。
3、它们都不对外提供构造方法，即构造方法都为私有。


## 多层架构软件设计经验

# 软件测试
## 测试工具


# 操作系统、数据库与网络
## Linux 平台

## 数据库与SQL语言
数据库的存储过程、视图、索引的建立及管理

## 计算机网络及分布式系统
1、通信网络模型
计算机   7层模型						5层模型
        应用层						应用层
        表示层						
        会话层
        运输层						运输层(TCP)
        网络层						网络层(IP)
        数据链路层					数据链路层
        物理层						物理层


# 开发编译平台
## Qt
Qt编程知识点
### 十进制string转为十六进制string：
QString strHex = QString::number(strInt.toInt(), 16);
strInt.toInt()有2个缺省参数如下，因默认值为nullptr，10，所以可以不赋值
bool bOk;
strInt.toInt(&bOk, 10)

### 十六进制string转为十进制string：
bool bOk;
QString strInt = QString::number(strHex.toInt(&bOk, 16), 10);

### 改变QLabel背景颜色
方法一：使用Qt调色板，代码如下：
 ui.label_Status->clear();
 QPalette palette;
 palette.setColor(QPalette::Background, QColor(R, G, B));
 ui.label_Status->setAutoFillBackground(true);  //一定要这句，否则不行
 ui.label_Status->setPalette(palette);

只要改变R,G,B的值即可实现各种颜色，例如（0, 255, 0）是绿色，（0， 0， 0）是黑色。

方法二：使用Qt样式表，qss语法直接修改
 ui->label->setText(""); //清空字体，和改变背景色没有关系，只是表示代码可放在一起
 QString strSheetStyle = "QLabel{background-color:rgb(200,101,102);}";
 ui->label->setStyleSheet(strSheetStyle);  //设置样式表
 
### 控件位置相关函数(Qt5)
获取控件窗体外边缘，左上角坐标位置：x()，y()，pos()
获取控件窗体外边缘，左上顶点、长宽值：frameGeometry()，frameGeometry().width()，frameGeometry().height()
获取控件窗体内中央区域的坐上顶点坐标及长宽值：geometry()，geometry().width()，geometry().height()
获取区域长宽值：width()，height()

设置控件位置和长宽：void setGeometry(int x, int y, int w, int h);

### .ui文件控件属性
geometry设置控件的左上角坐标和长宽 x,y,width,height
alignment设置控件内文本位置，水平位置和垂直位置，默认水平左对齐、垂直中心对齐

### 修改窗口展示风格

#include <QStyleFactory>
QApplication::setStyle(QStyleFactory::create("Fusion"));//设置窗口展示整体风格

w.setWindowTitle("微波消融仪软件消息解析工具");//设置窗口名称
w.setWindowFlags(w.windowFlags() & ~Qt::WindowMaximizeButtonHint);//除了最大化功能，其他功能保留
w.setWindowFlags(Qt::MSWindowsFixedSizeDialogHint);//设置窗口为固定大小


### 向Excel读写内容
.pro文件增加	QT += axcontainer
增加头文件	#include <QAxObject>
			#include <QVariant>//Excel读取出的数据只能用此类型容器进行存储
目前 Qt 6.2没有 QAxObject了，Qt 6.1.3有，需要卸载后安装6.1.3才能使用

### 向配置文件.ini读写内容

    QString strPath = QCoreApplication::applicationDirPath()+"/messCoinfig.ini";//获取app可执行文件所在位置
    QSettings settings(strPath, QSettings::IniFormat);

    /* //当文件不存在时，settings关联文件失败，无法获取到失败的错误码
    QSettings::Status enumStatus = settings.status();
    if(QSettings::NoError != enumStatus)
    {
        ui->messTypeContent_label->setText("打开messConfig.ini文件失败，或文件格式错误。");
        return;
    }*/

    settings.beginGroup(strSection);//定位到[strSection]组
    QStringList listKeys = settings.allKeys();//读取[strSection]组下的内容
    QString strKey;
    QString strValue;

    for(int i=0; i<listKeys.size(); i++)
    {
        strKey = listKeys.at(i);
        strValue = settings.value(strKey).toString();
        map.insert(strKey, strValue);
    }
    settings.endGroup();

### release运行程序方法

1、左下角选择：构建套件->release
2、左下角点击锤子按钮：进行构建
3、把..\build-CodeStreamTranslator-Desktop_Qt_6_2_4_MinGW_64_bit-Release\release文件夹下的可执行程序拷贝到新建文件夹
4、从电脑开始菜单找到Qt命令行工具，生成运行程序依赖的库文件：G:   //切换到上一步新建文件夹
													  cd 新建文件夹
													  windeployqt 应用程序名称.exe
5、把 messConfig.ini文件拷贝到新建文件夹下面
6、打压缩包，发布成功。


# 中间件
中间件是一种独立的系统软件服务程序，分布式应用软件借助这种软件在不同的技术之间共享资源，中间件位于客户机服务器的操作系统之上，管理计算资源和网络通信。
从这个意义上可以用一个等式来表示中间件：中间件=平台+通信，这也就限定了只有用于分布式系统中才能叫中间件


# 版本管理
## Git
帮助教程：[菜鸟教程](https://www.runoob.com/git/git-tutorial.html)
[简明指南：常用 git 命令、安装文件下载](https://www.runoob.com/manual/git-guide/)
GIT小炒 常用git命令 《github-git-cheat-sheet.pdf》
[Git 完整命令手册](http://git-scm.com/docs)
[GitHub帮助](https://docs.github.com/cn)

Git 是分布式的，SVN不是

1. 本地使用Git做本地工作空间和本地版本库(工作空间中隐藏目录.git文件夹)
2. 远程使用Github做远程仓库 Github 可以在官网 https://github.com/注册。 【速度慢，不选择】
2. 远程使用Gitee做远程仓库
2. 远程使用自己搭建的Git服务器  【暂不选择自己搭建】

工作区【git配置的仓库文件夹】
暂存区【仓库中隐藏文件 /.git/index】
版本库【仓库中隐藏目录 /.git 中除index之外的内容】

1. Git配置 git config
$ git config --system 写 git安装目录/etc/gitconfig文件，系统中对所有用户都普遍使用的配置。
$ git config --global 写 ~/.gitconfig文件，用户目录下的配置文件只适用于该用户【本地在 C:\Users\Administrator\.gitconfig 位置】

1.1 配置用户信息
Git bash 增加提交者姓名和邮箱，用于提交历史追溯
$ git config --global user.name "wyf"
$ git config --global user.email koala228@163.com
1.2 配置文本编辑器
$ git config --global core.editor Vim【或者其他，如emacs】
1.3 配置差异分析工具
$ git config --global merge.tool vimdiff
1.4 查看配置信息
$ git config --list
$ git config user.name

2. 常用命令
$ git add *.c					//把文件夹中所有.c文件添加到暂存区
$ git add -A					//本地所有变化提交到暂存区
$ git commit -m "提交注释"		//本地提交到版本库
$ git checkout <branch-name>	//切换工作区分支代码，即本地版本库分支下载到工作区
$ git clone					//从远程或本地拷贝内容到本地版本库
$ git fetch <remote-name>		//从远程下载内容到本地版本库，序号和merge配合才能合并到工作区
$ git push <remote-name> <branch-name>//本地版本库内容上传到远程版本库，上传远程代码并合并
$ git pull		//远程版本库内容拷贝到本地工作区，下载远程代码并合并

$ git init <folder-name>//在folder下，建立本地仓库(认为仓库包含 工作区、暂存区、版本库)
$ git status		//产科仓库当前状态，显示有变更的文件
$ git diff			//比较暂存区和工作区的差异
$ git reset			//回退版本
$ git log	--oneline	//查看历史提交记录，每次提交显示一行

### 本地使用Git做本地工作空间和本地版本库(工作空间中隐藏目录.git文件夹)
1、启动 Git Gui，创建本地仓库
2、配置用户信息
Git bash 增加提交者姓名和邮箱，用于提交历史追溯
$ git config --global user.name "wyf"
$ git config --global user.email koala228@163.com
3、Git Gui 操作
Rescan			扫描工作区的变化
Stage Changed	本地变化提交到暂存区（Unstaged Changes提交到Staged Changes）
Sign Off
Commit			暂存区提交到本地版本库（Staged Changes提交到本地版本库）
Push
4、查看提交历史
Git Gui ：菜单 Repository->Visualize All Branch History
Git bash：git log
		  git log --oneline

### 远程使用GitHub做远程仓库
[建立GitHub远程仓库操作流程，菜鸟教程](https://www.runoob.com/git/git-remote-repo.html)
《配置ssh连接github服务器.docx》
《Git原理及连接github基本操作.docx》

1、GitHub建立新账户
koala228@163.com
ghjlxzh@163 //git hub jian li xin zhang hu
用户名：remoWorkSpace
2、本地和GitHub新账户之间建立ssh连接
3、建立本地仓库和GitHub仓库，建立仓库的关联关系 git remote add <remote-name> <remote-address> 
注：remote-name是自己起的，远程仓库的别名


问题：
git remote add origin https://github.com/remoWorkSpace/QtProj.git 是把已经存在的远程版本库连接到本地
如何在本地增加一个实体远程版本库

### 远程使用Gitee做远程仓库


字体: Consolas, 字体颜色: 自定义颜色(RGB(248,248,242)), 段落间距
    段前: 6 磅
    段后: 6 磅, 边框:
    顶端: (单实线, 灰色-20%,  0.75 磅 行宽, 距正文:  12 磅 边框间距: )
    底端: (单实线, 灰色-20%,  0.75 磅 行宽, 距正文:  12 磅 边框间距: )
    左侧: (单实线, 灰色-20%,  0.75 磅 行宽, 距正文:  12 磅 边框间距: )
    右侧: (单实线, 灰色-20%,  0.75 磅 行宽, 距正文:  12 磅 边框间距: )
    图案: 清除 (自定义颜色(RGB(39,40,34))), 样式: 链接, 在样式库中显示
    基于: HTML 预设格式



## SVN


## CVS


# 其他
## 字节序
- Little endian 小端：将低序字节放在低地址
- Big endian    大端：将高序字节放在低地址
0x1234abcd 放到内存中
内存地址  大端  小端
0x0000   0x12  0xcd
0x0001   0x34  0xab
0x0002   0xab  0x34
0x0003   0xcd  0x12

- 主机字节序：大端、小端都有
- 网络字节序：大端
网络字节序使用大端，为方便阅读，码流的内存地址从低位到高位读，内容按照书写从高位到低位读

# 叠拓
radio daot
5季发，3、4收？
室内信号提升
Linux，C++，C，Java，python
英语交流
明年3月搬到欧尚后面




# 心得：
把功能点放到叶子函数中，稳定不变，也便于单元测试，业务逻辑相当于外壳，调用各种功能点，组成完整程序